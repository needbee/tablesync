<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Tablesync by needbee</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Tablesync</h1>
        <p>Field-level table synchronization, including algorithm, RESTful API spec, and reference implementations.</p>

        <p class="view"><a href="https://github.com/needbee/tablesync">View the Project on GitHub <small>needbee/tablesync</small></a></p>


        <ul>
          <li><a href="https://github.com/needbee/tablesync/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/needbee/tablesync/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/needbee/tablesync">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
<h3>
<a name="overview" class="anchor" href="#overivew"><span class="octicon octicon-link"></span></a>Overview</h3>

<p>This page is a proposal for a simple tabular data table synchronization algorithm that is easily implementable by developers who are comfortable with basic database and web service programming.</p>

<p>The web brought the thin-client paradigm back to the forefront. In this paradigm, data is stored in a single server-side database, so no data synchronization is needed. With the advent of mobile applications, however, the thick client is back. In this paradigm, mobile users have a number of expectations that cannot be met by a single server-side database:</p>

<ul>
<li>They expect that their data is available and editable whether or not they have an internet connection.</li>
<li>They expect that their data is synchronized between multiple devices (and the web interface, if there is one).</li>
<li>They expect this synchronization to be transparent and reliable: they should not need to know when data is up-to-date or not, and they should not need to reconcile conflicts.</li>
</ul>

<p>The following is a proposal for a simple way to achieve these goals. It's not a foolproof algorithm, but it should work for most basic cases. In addition to the above requirements, the following design principles were followed:</p>

<ul>
<li>Technology independence. Any two tabular data repositories should be able to be synchronized, as long as they are able to communicate over the network.</li>
<li>Synchronziation happens at the field level. If the user changes field A on a record on one device and field B on another record elsewhere, both updates should be preserved.</li> 
<li>As much as possible, standand relational database paradigms should be used on both the client and server side. Any restrictions on table design or extra metadata stored should be minimal.</li>
<li>Device time can be considered reliable for the sake of versioning. Increasing user of network time servers makes this more likely. In the case of a device getting out of sync, this algorithm is designed for situations where changes are infrequent enough and changes are low-risk enough that a problematic error is unlikely.</li>
</ul>

<h3>
<a name="overview" class="anchor" href="#design"><span class="octicon octicon-link"></span></a>Design</h3>

<h4>Database Changes</h4>

<p>Only a few changes need to be made to the database to support synchronization.</p>

<ol>
<li>Instead of incremental IDs, the primary keys need to be non-incremental, manually specified. This will allow each client to have its own set of primary key values, so that records added at the same time in multiple clients don't conflict. This could hypothetically be an int, but for the sake of clarity here it will be a CHAR field.</li>
<li>A single metadata table needs to be added on both the client and server side: (specified here in terms of MySQL, but just needs to store analogous data)</li>
</ol>

<table>
  <caption>Table <code>changes</code></caption>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Size</th>
      <th>Null</th>
      <th>Extra</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>action</td>
      <td>ENUM('CREATE', 'SET_FIELD', 'DELETE')</td>
      <td></td>
      <td>NOT NULL</td>
      <td></td>
    </tr>
    <tr>
      <td>table_name</td>
      <td>VARCHAR</td>
      <td>50</td>
      <td>NOT NULL</td>
      <td></td>
    </tr>
    <td>
      <td>pk</td>
      <td>CHAR</td>
      <td>17</td>
      <td>NOT NULL</td>
      <td></td>
    </td>
    <tr>
      <td>field_name</td>
      <td>VARCHAR</td>
      <td>50</td>
      <td>NULL</td>
      <td></td>
    </tr>
    <tr>
      <td>timestamp</td>
      <td>TIMESTAMP</td>
      <td></td>
      <td>NOT NULL</td>
      <td>CURRENT_TIMESTAMP</td>
    </tr>
  </tbody>
</table>

<h4>Primary Keys</h4>

<p>When a client is initialized for the first time, it must connect to the server to get a client ID. This is a unique 8-character string issued by the server. It should be stored by the client indefinitely. It is used for creating primary keys: whenever a client creates a new record, it creates a primary key by concatenating the client ID, a hyphen, and an 8-character record ID that is unique within that table. The combination of the client ID and record ID are ensured to be unique across all clients, so that there will never be a duplicated primary key. The application can determine which characters are valid characters to include in the client ID and record ID.</p>

<p>For example, a client might be issued the client ID 'nDHeYUOc'. When creating a new record, the record ID generated might be '3CG602mp'. In this case, the primary key of that record would be 'nDHeYUOc-3CG602mp'. This would be unique across all clients because no other clients' records would start with 'nDHeYUOc', and the client would ensure that no other records on that table would end with '3CG602mp'.</p>

<h4>Recording Changes</h4>

<p>When an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operation is done in the client database, it needs to be recorded in the <code>changes</code> table. They are recorded as follows:</p>

<ul>
<li><code>INSERT</code>: add a record to the <code>changes</code> table with action = 'CREATE'. Include the primary key. Then, for each field that was set as part of the statement, add a record to the <code>changes</code> table with action = 'SET_FIELD'.</li>
<li><code>UPDATE</code>: for each field that is set as part of the statement, add a record to the <code>changes</code> table with action = 'SET_FIELD'. To minimize sync bandwidth, not every field in the table should receive an UPDATE statement; just the fields that changed.</li>
<li><code>DELETE</code>: add a record to the <code>changes</code> table with action = 'DELETE'. Include the primary key.</li>
</ul>

<!--
<pre><code>$ cd your_repo_root/repo_name
$ git fetch origin
$ git checkout gh-pages
</code></pre>
-->
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/needbee">needbee</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>