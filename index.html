<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Tablesync by needbee</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Tablesync</h1>
        <p>Field-level table synchronization, including algorithm, RESTful API spec, and reference implementations.</p>

        <p class="view"><a href="#overview">Overview</a></p>
        <p class="view"><a href="#algorithm">Algorithm</a></p>
        <p class="view"><a href="#api-spec">API Specification</a></p>
        <p class="view"><a href="#ref-impl">Reference Implementation</a></p>

      </header>
      <section>
<h3>
<a name="overview" class="anchor" href="#overivew"><span class="octicon octicon-link"></span></a>Overview</h3>

<p>This page is a proposal for a simple tabular data table synchronization algorithm that is easily implementable by developers who are comfortable with basic database and web service programming.</p>

<p>The web brought the thin-client paradigm back to the forefront. In this paradigm, data is stored in a single server-side database, so no data synchronization is needed. With the advent of mobile applications, however, the thick client is back. In this paradigm, mobile users have a number of expectations that cannot be met by a single server-side database:</p>

<ul>
<li>They expect that their data is available and editable whether or not they have an internet connection.</li>
<li>They expect that their data is synchronized between multiple devices (and the web interface, if there is one).</li>
<li>They expect this synchronization to be transparent and reliable: they should not need to know when data is up-to-date or not, and they should not need to reconcile conflicts.</li>
</ul>

<p>The following is a proposal for a simple way to achieve these goals. It's not a foolproof algorithm, but it should work for most basic cases. In addition to the above requirements, the following design principles were followed:</p>

<ul>
<li>Technology independence. Any two tabular data repositories should be able to be synchronized, as long as they are able to communicate over the network.</li>
<li>Synchronziation happens at the field level. If the user changes field A on a record on one device and field B on another record elsewhere, both updates should be preserved.</li> 
<li>As much as possible, standand relational database paradigms should be used on both the client and server side. Any restrictions on table design or extra metadata stored should be minimal.</li>
<li>Device time can be considered reliable for the sake of versioning. Increasing user of network time servers makes this more likely. In the case of a device getting out of sync, this algorithm is designed for situations where changes are infrequent enough and changes are low-risk enough that a problematic error is unlikely.</li>
</ul>

<h3>
<a name="algorithm" class="anchor" href="#algorithm"><span class="octicon octicon-link"></span></a>Algorithm</h3>

<p>The system needs to handle inserts, updates, and deletes. Since the updates case is the most complex, let's start with that.</p>

<h4>Field Updates</h4>

<p>To synchronize field changes, the client will need to be able to tell the server which fields have changed since the last sync, and what their new values are. Because of this, the client will need to track two types of metadata.</p>

<p>First, the client will need to track the time of last sync.</p>

<p>Second, the client will need to track field changes themselves. It actually doesn't need to keep a record of every time a field changes; just the fact that it changed at least once since the last sync, and what the latest value is. Therefore we only need at most one change entry for each field.</p>

<p>This is sufficient for a one-directional sync, but what if fields have changed on the server as well? Which change wins? To determine this, we need to record the time that the field change was made. Whichever of the two changes was made later will be taken as the correct value.</p>

<p>We can track this information about field change times by creating a metadata table with the following fields, on both the client and server:</p>

<table>
  <caption>Table <code>changes</code></caption>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Size</th>
      <th>Required</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>action</td>
      <td>Either CREATE, SET_FIELD, or DELETE</td>
      <td></td>
      <td>required</td>
      <td>unique index A</td>
    </tr>
    <tr>
      <td>table name</td>
      <td>string</td>
      <td>50</td>
      <td>required</td>
      <td>unique index A</td>
    </tr>
    <tr>
      <td>primary key</td>
      <td>string</td>
      <td>17</td>
      <td>required</td>
      <td></td>
    </tr>
    <tr>
      <td>field name</td>
      <td>string</td>
      <td>50</td>
      <td>optional</td>
      <td>unique index A</td>
    </tr>
    <tr>
      <td>timestamp</td>
      <td>timestamp</td>
      <td></td>
      <td>required</td>
      <td>set to current timestap</td>
    </tr>
  </tbody>
</table>

<p>For now, we are only considering the SET_FIELD action. Note that the value of the field does not need to be stored in the metadata table; that can be retrieved from the main table itself. Also note that there is a unique index on action, table name, and field name, so there will only be one SET_FIELD entry for each field.</p>

<p>The sync operation works as follows:</p>

<ol>
<li>The client sends a sync request to the server. It sends the time of last sync, as well as all of the field update records, including the time of the change and what the new value is.</li>
<li>The server compares each field's update time against its own update times for that field. If the client's time is later, the field is updated (and the server's field update time is updated as well).</li>
<li>The server then finds any fields that have changed since the last sync (except for those changed by that client). These field values are sent back to the client (update time is not needed).</li>
<li>The client updates any field values sent back from the server.</li>
<li>The client empties its <code>changes</code> table, since that data is no longer needed.</li>
</ol>

<h4>Record Deletion</h4>

<p>Record deletion is easy to sync: just add a table change record with an action of DELETE. When it is synced up to the server, the server deletes the appropriate records from the main table, then stores the DELETE record. If a client receives a DELETE record back from the server, the client deletes the appropriate record.</p>

<h4>Record Creation</h4>

<p>Record creation is a bit more complex because of primary keys. If autoincrementing integer primary keys are used, then if two clients create a record of the same type they will have the same primary key, and resolution will be needed. Instead, this system uses non-incremental primary keys, as follows.</p>

<p>When a client is initialized for the first time, it must connect to the server to get a client ID. This is a unique random string issued by the server. It should be stored by the client indefinitely. It is used for creating primary keys: whenever a client creates a new record, it creates a primary key by concatenating the client ID, a hyphen, and a record ID string that is unique within that table. The combination of the client ID and record ID are ensured to be unique across all clients, so that there will never be a duplicated primary key. The application can determine which characters are valid characters to include in the client ID and record ID.</p>

<p>For example, a client might be issued the client ID 'nDHeYUOc'. When creating a new record, the record ID generated might be '3CG602mp'. In this case, the primary key of that record would be 'nDHeYUOc-3CG602mp'. This would be unique across all clients because no other clients' records would start with 'nDHeYUOc', and the client would ensure that no other records on that table would end with '3CG602mp'.</p>

<p>To sync the record creation, a CREATE record is added to the <code>changes</code> table, specifying the primary key that the client chose. Note that, unlike in SQL, the CREATE record does not specify initial values for other fields. Those should be logged as separate SET_FIELD records.</p>

<p>If the server has required columns (i.e. NOT NULL columns in a SQL database), then the server may need to implement record creation by looking for all SET_FIELD records for that same primary key, and setting all the values at once.</p>

<p>As usual, the server stores the CREATE records and sends them down to clients. Clients create the record as needed.</p>

<h4>Initial Data Download</h4>

<p>Since data transfer of all updates happens through the same sync interface, it would be nice if initial data population could be done through the same interface as well. This is fairly straightforward:</p>

<ol>
<li>The client requests a sync and does not specify a start time.</li>
<li>The server interprets this as a request to transfer all data. It needs to determine which data to return:
  <ol>
  <li>For any DELETE records, the server filters out any CREATE and SET_FIELD records for that primary key, since the record was ultimately deleted.</li>
  <li>However, no SET_FIELD records need to be filtered out, since the server does not store every change made to them; only the latest value for them.</li>
  </ol>
</li>
<li>The server returns all records. (Note: this could be a lot of data, but data format optimization to minimize bandwidth used is handled as part of the RESTful API specification below. Ideally the data size should be able to be fairly close to the size it would take separate from this syncing system.)</li>
<li>The client applies all these changes as usual, resulting in an up-to-date database.</li>
</ol>

<h3>
<a name="api-spec" class="anchor" href="#api-spec"><span class="octicon octicon-link"></span></a>API Specification</h3>

<p>The following is a recommended RESTful JSON web service specification for performing synchronization using the above model. Analogous operations could be made using other data formats such as XML and other architectures such as SOAP.</p>

<h4>Getting a Client ID</h4>

<p>The Client ID is needed to create primary keys that are unique across all clients. Uniqueness is guaranteed by having a client ID issued from the server.</p>

<pre><code>POST /sync/client

Request Data: none

Response Data:
{
  "status": "success",
  "client": {
    "id": "â€¦"
  }
}
</code></pre>

<p>Semantically, the POST operation is creating a new Client object, which is then returned. That object only has a single field: the ID field.</p>

<h4>Syncing</h4>

<pre><code>POST /sync/changes

Request Headers:
  Tablesync-Since: 2014-03-23T07:00:00+05:00

Request Data: (changes at the client level for the server to make)
{
  "changes": [
    {
      "a": "SET_FIELD",
      "tb": "contacts",
      "k": "nDHeYUOc-3CG602mp",
      "f": "email",
      "tm": "2014-03-23T11:56:00+05:00",
      "v": "newemail@sample.org"
    }
  ]
}

Response Data: (changes at the server level for the client to make)
{
  "changes": [
    {
      "a": "SET_FIELD",
      "tb": "contacts",
      "k": "nDHeYUOc-3CG602mp",
      "f": "phone",
      "tm": "2014-03-22T20:56:00+05:00",
      "v": "555-555-5555"
    }
  ]
}
</code></pre>

<p>Note: the above data formats are fairly verbose, but have been chosen for the sake of simplicity. They could be compressed by, for example, grouping SET_FIELD operations by table and then by record. Alternatively, GZIP compression at the HTTP level may be sufficient.</p>

<h3>
<a name="ref-impl" class="anchor" href="#ref-impl"><span class="octicon octicon-link"></span></a>Reference Implementation</h3>

<h4>Database Changes</h4>

<p>Only a few changes need to be made to the database to support synchronization.</p>

<ol>
<li>Instead of incremental IDs, the primary keys need to be non-incremental, manually specified. This will allow each client to have its own set of primary key values, so that records added at the same time in multiple clients don't conflict. This could hypothetically be an int, but for the sake of clarity here it will be a CHAR field.</li>
<li>A single metadata table needs to be added on both the client and server side: (specified here in terms of MySQL, but just needs to store analogous data)</li>
</ol>

<h4>Primary Keys</h4>

<p>When a client is initialized for the first time, it must connect to the server to get a client ID. This is a unique 8-character string issued by the server. It should be stored by the client indefinitely. It is used for creating primary keys: whenever a client creates a new record, it creates a primary key by concatenating the client ID, a hyphen, and an 8-character record ID that is unique within that table. The combination of the client ID and record ID are ensured to be unique across all clients, so that there will never be a duplicated primary key. The application can determine which characters are valid characters to include in the client ID and record ID.</p>

<p>For example, a client might be issued the client ID 'nDHeYUOc'. When creating a new record, the record ID generated might be '3CG602mp'. In this case, the primary key of that record would be 'nDHeYUOc-3CG602mp'. This would be unique across all clients because no other clients' records would start with 'nDHeYUOc', and the client would ensure that no other records on that table would end with '3CG602mp'.</p>

<h4>Recording Changes</h4>

<p>When an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operation is done in the client database, it needs to be recorded in the <code>changes</code> table. They are recorded as follows:</p>

<ul>
<li><code>INSERT</code>: add a record to the <code>changes</code> table with action = 'CREATE'. Include the primary key. Then, for each field that was set as part of the statement, add a record to the <code>changes</code> table with action = 'SET_FIELD'.</li>
<li><code>UPDATE</code>: for each field that is set as part of the statement, add a record to the <code>changes</code> table with action = 'SET_FIELD'. To minimize sync bandwidth, not every field in the table should receive an UPDATE statement; just the fields that changed.</li>
<li><code>DELETE</code>: add a record to the <code>changes</code> table with action = 'DELETE'. Include the primary key.</li>
</ul>

<!--
<pre><code>$ cd your_repo_root/repo_name
$ git fetch origin
$ git checkout gh-pages
</code></pre>
-->
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/needbee">needbee</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>